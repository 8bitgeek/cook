#!/usr/bin/python3

import argparse
import os,codecs
import math,time
import json

feature={}
source={}
fault='OK'

def load_json_text( fn ):
    json_text=''
    # @FIXME handle file open failure exception gracefully
    with codecs.open(fn, 'r', encoding='utf-8', errors='ignore') as fo:
        not_eof = True
        while not_eof:
            line = fo.readline()
            if line:
                json_text+=line
            else:
                not_eof = False
        fo.close()
    return json_text

def update_feature( dn, fn, meta ):
    metaobj={}
    metaobj[fn]=meta
    if ( feature.get(dn) == None ):
        feature[dn]=[]
    feature[dn].append(metaobj)
    return 

def update_source( dn, fn, meta ):
    metaobj={}
    metaobj[fn]=meta
    if ( source.get(dn) == None ):
        source[dn]=[]
    source[dn].append(metaobj)
    return 

def classify( dn ):
    if ( dn.find('/_feature/') >= 0 ):
        return 'feature'
    if ( dn.find('/_src/') >= 0 ):
        return 'src'
    return ''

def parse_cache( cache_fn ):
    json_text = load_json_text(cache_fn)
    cache = json.loads(json_text)
    for fileno in range(len(cache["cache"])):
        metadata={}
        metaobj = cache["cache"][fileno]
        print(json.dumps(metaobj, sort_keys=False, indent=4))
        if ( metaobj.get("meta") ):
            metadata = metaobj["meta"]
        filepath = metaobj["fn"]
        dn=os.path.dirname(filepath)
        fn=os.path.basename(filepath)
        if ( classify(dn) == 'feature' ):
            update_feature(dn,fn,metadata)
        else:
            update_source(dn,fn,metadata)
    return 

def write_feature_fragments():
    rc = 'OK'
    print('{"feature":')
    print(json.dumps(feature, sort_keys=False, indent=4))
    print('}')
    return rc

def write_source_fragments():
    rc = 'OK'
    print('{"source":')
    print(json.dumps(source, sort_keys=False, indent=4))
    print('}')
    return rc

def write_fragments():
    rc=write_source_fragments()
    if ( rc == 'OK' ):
        print(',')
        rc=write_feature_fragments()
    return rc

parser = argparse.ArgumentParser(description='Parses cook meta cache output and generate makefile snippet output.')
parser.add_argument('--cache', nargs='*', help='cache file to scan')

file_count=0
args = parser.parse_args()
for cacheno in range(len(args.cache)): 
    cache_name=args.cache[cacheno]
    parse_cache(cache_name)

fault = write_fragments()
if ( fault == 'OK' ):
    exit(0)
else:
    print(fault)
    exit(-1)
