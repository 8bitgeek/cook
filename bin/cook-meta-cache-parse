#!/usr/bin/python3

import argparse
import os,codecs
import math,time
import json

feature={}
source={}

def load_json_text( fn ):
    json_text=''
    # @FIXME handle file open failure exception gracefully
    with codecs.open(fn, 'r', encoding='utf-8', errors='ignore') as fo:
        not_eof = True
        while not_eof:
            line = fo.readline()
            if line:
                json_text+=line
            else:
                not_eof = False
        fo.close()
    return json_text

def update_feature( dn, fn, meta ):
    if ( feature.get(dn) == None ):
        metaobj={}
        metaobj[fn]=meta
        if ( feature.get(dn) == None ):
            feature[dn]=[]
        feature[dn].append(metaobj)
    return 

def update_source( dn, fn, meta ):
    if ( source.get(dn) == None ):
        metaobj={}
        metaobj[fn]=meta
        if ( source.get(dn) == None ):
            source[dn]=[]
        source[dn].append(metaobj)
    return 

def classify( dn ):
    if ( dn.find('/_feature/') >= 0 ):
        return 'feature'
    if ( dn_find('/_src/') >= 0 ):
        return 'src'
    return ''

def parse_cache( cache_fn ):
    json_text = load_json_text(cache_fn)
    cache = json.loads(json_text)
    for fileno in range(len(cache["cache"])):
        metaobj = cache["cache"][fileno]
        metadata = metaobj["meta"]
        filepath = metaobj["fn"]
        dn=os.path.dirname(filepath)
        fn=os.path.basename(filepath)
        if ( classify(dn) == 'feature' ):
            update_feature(dn,fn,metadata)
        else:
            update_source(dn,fn,metadata)
    return 

def write_feature_fragment():
    print(feature)
    return

def write_source_fragment():
    print(source)
    return

def write_fragments():
    # @FIXME write the fragments
    return

parser = argparse.ArgumentParser(description='Parses cook meta cache output and generate makefile snippet output.')
parser.add_argument('--cache', nargs='*', help='cache file to scan')

file_count=0
args = parser.parse_args()
for cacheno in range(len(args.cache)): 
    cache_name=args.cache[cacheno]
    parse_cache(cache_name)
write_fragments()
